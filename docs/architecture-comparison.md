# 本地 CLI 工具 vs 云端沙箱架构对比

> 本文档分析本地 CLI 代码执行工具（如 Claude Code）与云端沙箱服务的架构差异，帮助理解本项目的设计目标和使用场景。

## 1. 两种执行模型

### 1.1 本地 CLI 工具模型（如 Claude Code）

```
┌─────────────────────────────────────────────────────────┐
│                    用户本地机器                          │
│                                                         │
│   ┌──────────────┐      ┌──────────────────────────┐   │
│   │   CLI 工具   │ ───→ │  直接执行 Bash/读写文件   │   │
│   │  (本地进程)   │      │  （用户的真实环境）        │   │
│   └──────────────┘      └──────────────────────────┘   │
│                                                         │
│   能访问: 用户文件、安装软件、运行代码、git 操作...       │
│   安全边界: 用户授权确认 + 工具内置限制                   │
└─────────────────────────────────────────────────────────┘
```

**特点：**
- 代码在用户本地环境直接执行
- 无沙箱隔离，完全信任用户环境
- 适合开发者本人使用的辅助工具

### 1.2 云端沙箱模型（本项目目标）

```
┌─────────────────────────────────────────────────────────┐
│                       云端服务                           │
│                                                         │
│   ┌──────────┐     ┌─────────────────────────────────┐ │
│   │ 用户/Agent│ ──→ │         沙箱池                  │ │
│   │  (远程)   │     │  ┌─────┐ ┌─────┐ ┌─────┐      │ │
│   └──────────┘     │  │ VM1 │ │ VM2 │ │ VM3 │ ...  │ │
│                     │  │隔离的│ │隔离的│ │隔离的│      │ │
│                     │  └─────┘ └─────┘ └─────┘      │ │
│                     └─────────────────────────────────┘ │
│                                                         │
│   每个沙箱: 独立文件系统、网络隔离、资源限制              │
│   安全边界: 硬件级隔离（Firecracker）/ 容器隔离          │
└─────────────────────────────────────────────────────────┘
```

**特点：**
- 代码在远程隔离环境执行
- 多租户安全隔离
- 支持会话暂停/恢复
- 适合产品级代码执行服务

---

## 2. 核心区别对比

| 方面 | 本地 CLI 工具 | 云端沙箱服务 |
|------|---------------|--------------|
| **执行位置** | 用户本地机器 | 远程服务器 |
| **隔离级别** | 无隔离，直接访问 | 硬件级/容器级隔离 |
| **信任模型** | 用户信任工具 | 服务不信任执行的代码 |
| **目标用户** | 开发者本人 | 任意用户 / AI Agent |
| **状态管理** | 依赖本地文件系统 | 可暂停/恢复/快照 |
| **并发能力** | 单用户 | 1000+ 并发沙箱 |
| **资源限制** | 共享本地资源 | 每沙箱独立配额 |
| **网络访问** | 完全访问 | 可配置白名单 |

---

## 3. 为什么需要云端沙箱？

### 场景 A：AI 编码助手产品（类似 Claude Artifacts）

```
用户在网页上: "帮我用 Python 画个销售趋势图"
     ↓
服务器收到请求，LLM 生成 Python 代码
     ↓
代码需要在某个地方执行
  - 不能在用户浏览器里执行 Python
  - 不能在服务器主机上直接执行（安全风险）
     ↓
需要云端沙箱！在隔离环境中安全执行，返回结果
```

### 场景 B：自主 Agent（类似 Manus / Devin）

```
用户任务: "帮我搭建一个 Todo 应用的后端"
     ↓
Agent 自动规划并执行:
  - mkdir src/
  - 创建代码文件
  - pip install fastapi
  - pytest 运行测试
     ↓
不能让 Agent 直接操作生产服务器（风险太高）
     ↓
需要云端沙箱！Agent 在沙箱中完成任务，用户验收后再部署
```

### 场景 C：在线编程教育（类似 LeetCode）

```
1000 个学生同时提交代码
     ↓
每个人的代码可能包含:
  - Bug 导致死循环
  - 消耗大量内存
  - 恶意代码尝试攻击
     ↓
需要隔离执行，互不影响，超时自动终止
     ↓
需要云端沙箱！
```

### 场景 D：会话持久化

```
Day 1: 用户开始数据分析项目
  - 上传数据文件
  - 安装依赖包
  - 生成中间结果
  → sandbox.pause() 保存状态

Day 2: 用户继续工作
  → sandbox.resume() 恢复状态（< 500ms）
  - 所有文件、依赖、变量都在
  - 无需重新配置环境
```

---

## 4. 本项目定位

**Cloud Sandbox for Coding Agents** 是一个 **"代码执行即服务" (Code Execution as a Service)** 基础设施，目标是：

1. **为 AI Agent 提供安全执行环境** - LLM 生成的代码可以安全执行
2. **支持产品级多租户** - 1000+ 并发沙箱，99.9% 可用性
3. **快速启动和恢复** - 启动 < 200ms，恢复 < 500ms
4. **硬件级安全隔离** - 使用 Firecracker microVM

---

## 5. 架构演进路线

### Phase 1: MVP（Docker 容器隔离）
- 适合开发测试和小规模部署
- 进程级隔离，满足基本安全需求

### Phase 2: 生产就绪（Firecracker microVM）
- 硬件级隔离，安全性更高
- 快照/恢复功能
- 沙箱池预热

### Phase 3: 企业级
- 完整网络隔离
- 审计日志
- 多租户资源配额

---

## 6. 总结

| 工具类型 | 代表产品 | 核心价值 |
|----------|----------|----------|
| 本地 CLI | Claude Code, Cursor | 帮开发者在**自己的环境**里高效工作 |
| 云端沙箱 | E2B, 本项目 | 让**不受信任的代码**在**隔离环境**中安全执行 |

两者是互补关系：
- 开发者使用本地 CLI 工具提高效率
- 产品使用云端沙箱为终端用户提供代码执行能力
